      <!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /> <meta http-equiv="X-UA-Compatible" content="IE=edge" /> <meta name="viewport" content="width=device-width, initial-scale=1" />  <title>Guide | reLift-HTML</title>   <meta name="title" content="Guide">   <link rel="canonical" href="https://relift-html.js.org/"/>     <meta name="description" content="reLift-HTML guide.">        <meta name="rating" content="General">      <meta name="language" content="en-us">      <meta name="robots" content="index, follow">      <meta name="keywords" content="">      <meta property="og:title" content="Guide">   <meta property="og:description" content="reLift-HTML guide.">   <meta property="og:url" content="https://relift-html.js.org//guide/">   <meta property="og:site_name" content="reLift-HTML">   <meta property="og:type" content="article">   <meta itemprop="description" content="reLift-HTML guide.">   <meta itemprop="name" content="Guide">   <meta itemprop="url" content="https://relift-html.js.org//guide/">   <meta name="twitter:title" content="Guide">   <meta name="twitter:description" content="reLift-HTML guide.">   <meta name="twitter:url" content="https://relift-html.js.org//guide/">    <meta name="twitter:card" content="summary">       <link rel="stylesheet" href="https://relift-html.js.org/static/vendor/normalize.css" type="text/css" >    <link rel="stylesheet" href="https://relift-html.js.org/static/vendor/milligram.css" type="text/css" >    <link rel="stylesheet" href="https://relift-html.js.org/static/main.css" type="text/css" >  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css" integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" crossorigin="anonymous">   <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Roboto:300,300italic,700,700italic" type="text/css" >  </head> <body>   <link rel="stylesheet" href="https://relift-html.js.org/static/pages_assets__/guide-index-html_b0d03653e0d141db8abc60b5652c6271.css" type="text/css" >  <div class="wrapper"> <nav class="navigation"> <section class="container"> <a class="navigation-title" href="https://relift-html.js.org/"><h1 class="title">reLift-HTML</h1></a> <ul class="navigation-list float-right"> <li><a href="https://relift-html.js.org/guide/"><strong>GUIDE</strong></a></li> <li><a href="https://relift-html.js.org/demo/">DEMO</a></li> <li><a target="_blank" href="https://github.com/mardix/relift-html">GITHUB</a></li> </ul> </section> </nav> </div>  <div class="wrapper"> <header class="header header-dark"> <div class="container" id="guide-header"> <h2 class="title">GUIDE</h2> </div> </header> <div class="container"> <div class="row"> <div class="column column-25" id="sideMenu"> <div id="menu-toggler" @call="toggleMenuToggler"> <i class="fas fa-bars"></i> </div> <div id="content-side-affix" class="top"> <ul class="side-nav"> <li r-for="item in this.menu" data-section="${item.url}"> <a href="#${item.url}" data-affix-link="#${item.url}">${item.title}</a> <ul> <li r-for="sitem in item.subsections"><a href="#${sitem.url}" data-affix-link="#${sitem.url}">${sitem.title}</a></li> </ul> </li> </ul> <div><a href="#" @call="scrollToTop">Back to top</a></div> <hr> <a href="https://github.com/mardix/relift-html/tree/master/docs" target="_blank">Edit on Github</a> </div> </div> <div class="column guides" id="page-guide">  <section class="doc" data-doc="introduction.md"> <h2 id="introduction">Introduction</h2> <div class="toc"> <ul> <li><a href="#introduction">Introduction</a><ul> <li><a href="#what-is-relift-html">What is reLift-HTML?</a></li> <li><a href="#template-literals">Template Literals</a></li> <li><a href="#features">Features</a></li> </ul> </li> </ul> </div> <h3 id="what-is-relift-html">What is reLift-HTML?</h3> <p><p><strong>reLift-HTML</strong> is a blazing fast view library that lets you write Javascript Template Literals in HTML. (Yup! You've read that right!)</p> <p>Inspired by, but unlike <em>lit-html</em> and <em>hyperHTML</em>, <strong>reLift-HTML</strong> makes it easy to write javascript in your HTML template using template literals. </p> <p>No need to know special React/JSX syntax or some other templaty stuff, HTML is your template. Use it the way you've used it before.</p> <p>If you need some values to be reactive, just place them in the template literal <code>${...}</code>, otherwise, keep going with your plain old HTML.</p> <p>Underneath, reLift-HTML will turn the html section into a modern template string literal, and upon receiving new data, it will re-render only sections that need to be rendered.</p> <p>reLift-HTML doesn't have a virtual DOM, therefor it doesn't keep a DOM tree in memory. Instead it relies on the real DOM, and only mutates it in place whenever there is change. This tends to be memory efficient, and also reduces GC activities</p></p> <h3 id="template-literals">Template Literals</h3> <p>Template Literal was introduced in ES2015 (ES6) as new way to create a string. </p> <p>To create a Template Literal, instead of single quotes (<code>'</code>) or double quotes (<code>"</code>) quotes we use the backtick ` character. This will produce a new string, and we can use it in any way we want.</p> <p>In the new Template Literal syntax we have what are called expressions, and they look like this: <code>${expression}</code></p> <p>The <code>${}</code> syntax allows us to put an expression in it and it will produce a value.</p> <pre><code class="js"> const name = 'reLift-HTML';
 console.log(`Hello this is ${name}`);
</code></pre> <p>reLift-HTML takes advantage of this feature to enhance HTML. You can add any expression in your HTML template, reLift-HTML will underneath turn it into Javascript Template Literals. </p> <h3 id="features">Features</h3> <p>reLift-HTML aims to be simple, easy to use and helps you do much more. </p> <ul> <li>Very small</li> <li>Template literals</li> <li>Directives</li> <li>Data binding</li> <li>Computed properties</li> <li>Event Handling</li> <li>Lifecycle</li> <li>State management</li> <li>HTML stays as is</li> <li>No JSX </li> <li>No dependency</li> <li>No virtual DOM</li> <li>No need for CLI</li> <li>No build, the real DOM does it!</li> </ul> </section> <hr>  <section class="doc" data-doc="installation.md"> <h2 id="installation">Installation</h2> <div class="toc"> <ul> <li><a href="#installation">Installation</a><ul> <li><a href="#importing-from-unpkgcom">Importing from unpkg.com</a></li> <li><a href="#npm">npm</a></li> <li><a href="#compatibility">Compatibility</a></li> </ul> </li> </ul> </div> <p><strong>reLift-HTML</strong> is written in ES2015 and distributed as standard JavaScript modules (ESM). Modules are increasingly supported in JavaScript environments and have shipped in Chrome, Firefox, Edge, Safari, and Opera.</p> <h3 id="importing-from-unpkgcom">Importing from unpkg.com</h3> <p>The recommended way to import <strong>reLift-HTML</strong> is via ESM javascript, where we specify the type <code>module</code> in the script tag, and we import it from <strong>unpkg.com</strong> </p> <p>Make sure <code>type="module"</code> exists in the script tag (<code>&lt;script type="module"&gt;</code>).</p> <pre><code class="html">
&lt;script type=&quot;module&quot;&gt;
  import reLiftHTML from '//unpkg.com/relift-html';

  ...

&lt;/script&gt;

</code></pre> <p>The JavaScript import statement only works inside module scripts (<code>&lt;script type="module"&gt;</code>), which can be inline scripts (as shown above) or external scripts:</p> <pre><code>
&lt;script type=&quot;module&quot; src=&quot;$PATH/script.esm.js&quot;&gt;&lt;/script&gt;

</code></pre> <h3 id="npm">npm</h3> <p>Or by installing it in your project</p> <pre><code>npm install relift-html
</code></pre> <pre><code class="js">import reLiftHTML from 'relift-html';
</code></pre> <h3 id="compatibility">Compatibility</h3> <p><strong>reLift-HTML</strong> is a modern library for moden browsers that support ES2015 (ES6), Template Literals, Proxy, and all the fun stuff.</p> <p>The library is written in ES2015, and will be delivered to you as such. To keep it small reLift-HTML doesn't have any polyfills nor extra code to make new ES20xx features available in non modern browsers, therefor it will not work with browsers that don't support ES6, Template Literals, Proxy, etc. </p> <p>https://caniuse.com/#feat=es6</p> <p>https://caniuse.com/#search=proxy</p> </section> <hr>  <section class="doc" data-doc="instance.md"> <h2 id="instance">Instance</h2> <div class="toc"> <ul> <li><a href="#instance">Instance</a><ul> <li><a href="#setup">Setup</a></li> <li><a href="#options">Options</a><ul> <li><a href="#el">el</a></li> <li><a href="#data">data</a></li> <li><a href="#created">created</a></li> <li><a href="#updated">updated</a></li> <li><a href="#template">template</a></li> <li><a href="#store">$store:</a></li> </ul> </li> <li><a href="#methods">Methods</a></li> <li><a href="#properties">Properties</a><ul> <li><a href="#thisel">this.el</a></li> <li><a href="#thisdata">this.data</a></li> <li><a href="#thisrender">this.render</a></li> <li><a href="#thisdefine-methods">...this.$define-methods</a></li> </ul> </li> </ul> </li> </ul> </div> <p>Every reLift-HTML application starts by creating a reLift-HTML instance with the <code>reLiftHTML</code> function.</p> <p>During the initilization process, reLift-HTML needs to prepare the HTML to template literals, setup data observation, setup event listeners, do the first update of the DOM, runs lifecycle hooks.</p> <h3 id="setup">Setup</h3> <p>Setting up an instance starts by invoking <code>reLiftHTML</code> function, which accepts options.</p> <pre><code>&lt;div id=&quot;root&quot;&gt;

&lt;/div&gt;

&lt;script type=&quot;module&quot;&gt;
  import reLiftHTML from '//unpkg.com/relift-html';

  reLiftHTML({
    el: '#root',
    data: {

    },
    created() {
    },
    updated() {
    },
    template: null,
    $store: null
  })
&lt;/script&gt;
</code></pre> <h3 id="options">Options</h3> <p>Every instance creation accepts the following options, with <code>el</code> being required.</p> <h4 id="el"><strong><code>el</code></strong></h4> <p>REQUIRED [string|HTMLElement] <br /> This is where the view instance will be created and rendered. By default, it will use the innerHTML of the element as template.<br /> This can be html selector , ie <code>#someId</code>, <code>[some-data-attribute]</code>. Or a query selector <code>document.querySelector('#myId')</code>. </p> <h4 id="data"><strong><code>data</code></strong></h4> <p>[object]<br /> Is the application state. All data in here are reactive. Whenever a property is added, updated or removed it will trigger the update of the DOM (if necessary).<br /> Values are expected to be the type string, number, plain object, boolean, null, undefined or <em>function</em>. <br /> In the case of a function, it will become a computated data.</p> <h4 id="created"><strong><code>created</code></strong></h4> <p>[function]<br /> This is a lifecycle hook method. It runs once the instance is created. </p> <h4 id="updated"><strong><code>updated</code></strong></h4> <p>[function]<br /> This is a lifecycle hook method. It runs each time the instance is updated. </p> <h4 id="template"><strong><code>template</code></strong></h4> <p>[string] <br /> A string/text that will be rendered in the <code>el</code> instance. By default the innerHTML of <code>el</code> will be used, but setting <code>template</code> allows you to provide your own template, and will overwrite the default behavior. </p> <h4 id="store"><strong><code>$store</code></strong>:</h4> <p>[state management interface]<br /> Unlike <code>data</code> store is where to hook a shared store manager, ie: reStated, Redux. The store instance must have the methods <code>getState()</code> and <code>subscribe(callback:function)</code>. </p> <h3 id="methods">Methods</h3> <p>Along the lifecycle methods <code>created</code> and <code>mounted</code>, you have the ability to define your own methods.</p> <p>The defined methods are set with the rest of the options.</p> <p><strong>WARNING</strong>: <br /> When creating methods don't use arrow functions such as <code>created: () =&gt; this.sayHello(),</code>. Since arrow function doesn't have a <code>this</code>, <code>this</code> will be treated as any other variable and will often result in error such as <code>Uncaught TypeError: Cannot read property of undefined</code> or <code>Uncaught TypeError: this.myMethod is not a function</code> </p> <pre><code>&lt;div id=&quot;root&quot;&gt;
&lt;/div&gt;

&lt;script type=&quot;module&quot;&gt;
  import reLiftHTML from '//unpkg.com/relift-html';

  reLiftHTML({
    el: '#root',
    data: {},
    created() {
      this.sayHello('reLiftHTML');
    },
    sayHello(name) {
      console.log(`Hello ${name}`)
    },

  })
&lt;/script&gt;
</code></pre> <h3 id="properties">Properties</h3> <p>Inside of the lifecycle and defined methods, you have access to the following properties:</p> <h4 id="thisel"><strong><code>this.el</code></strong></h4> <p>Is the instance root element. It allows you to safely query, manipulate the instance's DOM elements.</p> <pre><code class="js">  reLiftHTML({
    el: '#root',

    // will run each time there is a re-render
    updated() {
      const allLis = this.el.querySelectorAll('li');
      console.log(allList.length);
    }
  })
</code></pre> <h4 id="thisdata"><strong><code>this.data</code></strong></h4> <p>Gives you access to the reactive <code>data</code>. You can get, set and delete properties.<br /> Whenever a <code>data</code> is updated it will trigger re-render (if necessary). You don't have to pre define a property in <code>data</code> to make it reactive.</p> <pre><code class="js">  reLiftHTML({
    el: '#root',
    data: {
      name: ''
    },
    methodA() {
      this.data.name = 'Mardix'; // setter
      console.log(this.data.location) // getter
      this.data.myArray = [];
      this.data.myArray.push(1);
      console.log(this.data.myArray.length);
    }
  })
</code></pre> <h4 id="thisrender"><strong><code>this.render</code></strong></h4> <p>A function to manually re-render.</p> <pre><code class="js">  reLiftHTML({
    el: '#root',
    methodA() {
      /* do something, then... */
      this.render();
    }
  })
</code></pre> <h4 id="thisdefine-methods"><strong><code>...this.$define-methods</code></strong></h4> <pre><code class="js">  reLiftHTML({
    el: '#root',
    methodA() {
      this.methodB();
    },
    methodB() {
      this.methodC();
    }
    methodC() {
      console.log(`I'm method C :)`)
    }
  })
</code></pre> </section> <hr>  <section class="doc" data-doc="lifecycle.md"> <h2 id="lifecycle">Lifecycle</h2> <div class="toc"> <ul> <li><a href="#lifecycle">Lifecycle</a><ul> <li><a href="#properties">Properties</a></li> <li><a href="#created">created</a><ul> <li><a href="#example-with-async">Example with async</a></li> </ul> </li> <li><a href="#updated">updated</a><ul> <li><a href="#example-of-count-li">Example of count LI</a></li> </ul> </li> </ul> </li> </ul> </div> <p>For every instance that gets created, reLift-HTML provides two lifecycle methods that get added during the initialization.</p> <p>All lifecycle methods have:</p> <h4 id="properties">Properties</h4> <p><p>*All methods have access to the following instance's properties:</p> <p><strong><code>this.el</code></strong>: Is the instance root element. It allows you to safely query, manipulate the instance's DOM elements. ie: <code>this.el.querySelector('ul')</code></p> <p><strong><code>this.data</code></strong>: Gives you access to the reactive data. You can get, set and delete properties. Whenever a data is updated it will trigger re-render (if necessary), ie: <code>console.log(this.data.name)</code></p> <p><strong><code>this.render</code></strong> A function to manually re-render, ie: <code>this.render()</code></p> <p><strong><code>...this.$define-methods</code></strong> all of the defined methods, ie: <code>this.$my-defined-method()</code></p></p> <h3 id="created">created</h3> <p><code>created</code> runs <strong>once</strong> on <code>DOMContentLoaded</code>. At the time of running, the DOM is ready, you can query elements. </p> <p>It is also the place to initialize some async call, ajax etc.</p> <pre><code>  reLiftHTML({
    el: '#root',
    data: {

    },
    created() {
      //... code here
    }
  })
</code></pre> <h4 id="example-with-async">Example with async</h4> <pre><code>  reLiftHTML({
    el: '#root',
    data: {
      loading: false,
      loaded: false,
      results: []
    },
    async created() {
      // Could be used on the page to show spinner
      this.loading = true;
      this.loaded = false;

      const data = await fetch('some-url');
      const result = await data.json();
      this.data.results = results;

      // Tell the page everything is good to go
      this.loading = false;
      this.loaded = true;      
    }
  })
</code></pre> <h3 id="updated">updated</h3> <p><code>updated</code> runs only each time the state updates the DOM. This is a place to do any computations after an update.</p> <pre><code>  reLiftHTML({
    el: '#root',
    data: {

    },
    updated() {
      //... code 
    }
  })
</code></pre> <h4 id="example-of-count-li">Example of count LI</h4> <pre><code>  reLiftHTML({
    el: '#root',
    data: {
      totalLis: 0
    },
    updated() {
      const lis = this.el.querySelectorAll('li');
      this.data.totalLis = lis.length;
    }
  })
</code></pre> </section> <hr>  <section class="doc" data-doc="data.md"> <h2 id="data">Data</h2> <div class="toc"> <ul> <li><a href="#data">Data</a><ul> <li><a href="#data_1">data</a></li> <li><a href="#template">Template</a><ul> <li><a href="#what-about-this">What about this</a></li> </ul> </li> <li><a href="#local-state">Local state</a></li> <li><a href="#computed-state">Computed state</a></li> <li><a href="#example-of-making-async-call">Example of making Async call</a></li> <li><a href="#shared-state">Shared state</a></li> </ul> </li> </ul> </div> <p>Data is at the core of the instance's reactivity. Whenever data is changed, it will trigger a re-render (if necessary).</p> <p>Data is usally set during the instance's setup, under the <code>data</code> options.</p> <h4 id="data_1"><strong><code>data</code></strong></h4> <p>[object]<br /> Is the application state. All data in here are reactive. Whenever a property is added, updated or removed it will trigger the update of the DOM (if necessary).<br /> Values are expected to be the type string, number, plain object, boolean, null, undefined or <em>function</em>. <br /> In the case of a function, it will become a computed data.</p> <pre><code class="js">reLiftHTML({
  el: '#root',
  data: {
    firstName: 'Mardix',
    lastName: 'M.',
    fullName: (state) =&gt; `${state.firstName} ${state.lastName}`
  }
})
</code></pre> <p>Data in reLift-HTML is:</p> <ul> <li><strong>Accessible</strong>: in the template and methods you have direct access to the data </li> <li><strong>Mutable</strong>: in the methods you can mutate the data directly without setters, ie <code>this.data.aNumber = 1;</code> or <code>this.data.someArray.pop();</code></li> <li><strong>Reactive</strong>: whenever <code>this.data</code> is updated it will trigger a re-render (if necessary)</li> <li><strong>Dynamic</strong>: you don't have to pre define properties during the instance setup, you can set new properties in some other places or when needed, and automatically it will be also become reactive.</li> </ul> <h3 id="template">Template</h3> <p>In the template you have access to data via <code>this.#data-property-name</code>, where '#data-property-name' is the property name to access.</p> <pre><code class="html">
&lt;div id=&quot;root&quot;&gt;
  &lt;p&gt;Hello ${this.name}&lt;/p&gt;
  &lt;p&gt;Date: ${this.todaysDate}
&lt;/div&gt;

&lt;script type=&quot;module&quot;&gt;

  reLiftHTML({
    el: '#root',
    data: {
      name: 'reLift-HTML'
    },
    created() {
      // Dynamically added
      this.data.todaysDate = new Date().toLocaleString();
    }
  })
&lt;/script&gt;

</code></pre> <h4 id="what-about-this">What about <strong><code>this</code></strong></h4> <p><code>this</code> in your template indicate the root context of the data. By not putting <code>this</code>, the variable will fall under the global object, which is the <code>window</code> in the browser. With <code>this</code> we keep the data in scope. </p> <pre><code class="js">  &lt;div id=&quot;root&quot;&gt;
    &lt;!-- use from data --&gt;
    ${this.firstName}

    &lt;!-- fall under the global object/window --&gt;
    ${new Date().toLocaleString()}
  &lt;/div&gt;
</code></pre> <h3 id="local-state">Local state</h3> <p>Local state is the data that the instance will use. It is set in the <code>data</code>. Whenever it is updated, it will trigger a re-render (if necessary). </p> <p>In the template you have access to it via <code>${this.#data-property-name}</code> and in your methods it's via <code>this.data</code>;</p> <p>The state/data is mutable only in the methods of your instance, which means you can directly update the properties. No need for this.set(key, value) or this.get(key).</p> <p>You can do this: </p> <pre><code class="js">reLiftHTML({
  el: '#root',
  data: {
    name: 'reLift-HTML',
    count: 0
  },
  sayHello() {
    console.log(this.data.name);
  },
  changeName(name) {
    this.data.name = name;
  },
  runCounter(){
    setInterval(() =&gt; {
      this.data.count++;
    }, 1000)
  },
  created() {
    this.runCounter();
  }
})
</code></pre> <h3 id="computed-state">Computed state</h3> <p>Computed state are data that will be created based on some other input, usually from the reactive <code>data</code>. Whenever the state is updated, the computed data will also be updated. Which makes computed data reactive.</p> <p>Computed data are set as function that returns a value, which will be assigned to the name of the function in the <code>data</code> object. </p> <pre><code class="js">data: {
  firstName: 'Mardix',
  lastName: 'M.',

  // computed data, will be accessed via '${this.fullName}' or 'this.data.fullName'
  fullName(state) =&gt; `${state.firstName} ${state.lastName}`

  // computed data, will be accessed via '${this.totalChars}' or 'this.data.totalChars'
  totalChars(state) =&gt; state.fullName.length
}
</code></pre> <p>In the example above, we now can access as properties: <code>this.data.fullName</code> and <code>this.data.totalChars</code>. In the template, <code>${this.fullName}</code> and <code>${this.totalChars}</code></p> <p>NOTE 1: You can't access the computed data as functions in your code. <br /> NOTE 2: You can't mutate the state in the computed data funcion, nor access an instance's method in the computed data function.</p> <p>Computed data function accept the current state as the only argument, and must return a value. The value will be assigned in the <code>data</code> with the function name. The data provided in the computed data is not mutable. </p> <pre><code class="html">&lt;div id=&quot;root&quot;&gt;
  &lt;p&gt;Hello ${this.fullName}&lt;/p&gt;
&lt;/div&gt;

&lt;script type=&quot;module&quot;&gt;

  reLiftHTML({
    el: '#root',
    data: {
      firstName: 'Mardix',
      lastName: 'M.',
      fullName(state) =&gt; `${state.firstName} ${state.lastName}`
    }
  })
&lt;/script&gt;

</code></pre> <h3 id="example-of-making-async-call">Example of making Async call</h3> <p>The example below illustrate how we can make async call and at the same time setting the state to make it reactive.</p> <pre><code class="html">
&lt;div id=&quot;root&quot;&gt;

  &lt;div v-if=&quot;this.loadingStatus === 'loading'&quot;&gt;Loading...&lt;/div&gt;

  &lt;div v-if=&quot;this.loadingStatus === 'done'&quot;&gt;
    &lt;p&gt;Data loading successfully!&lt;/p&gt;
    &lt;ul&gt;
      &lt;li r-for=&quot;item in this.myData&quot;&gt;${item}&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;


&lt;/div&gt;

&lt;script type=&quot;module&quot;&gt;

  reLiftHTML({
    el: '#root',
    data: {
      loadingStatus: null,
      myData: []
    },
    async loadData() {
      this.loadingStatus = 'loading';

      const resp = await fetch('some-url');
      this.data.myData = await resp.json();

      this.loadingStatus = 'done';
    }
  })

&lt;/script&gt;

</code></pre> <h3 id="shared-state">Shared state</h3> <p>To share state with multiple instances, please refer to the <a href="#shared-state">SHARED STATE</a> section in this guide.</p> </section> <hr>  <section class="doc" data-doc="methods.md"> <h2 id="methods">Methods</h2> <div class="toc"> <ul> <li><a href="#methods">Methods</a><ul> <li><a href="#properties">Properties</a></li> <li><a href="#defined-method">Defined Method</a></li> <li><a href="#async-method">Async method</a></li> </ul> </li> </ul> </div> <p>You can define your own methods in the instance. </p> <p>Method can be used to be accessed by other methods via <code>this.$method-name(...args)</code>, or can be used as events methods in the instance of <code>@click="$method-name"</code></p> <h4 id="properties">Properties</h4> <p><p>*All methods have access to the following instance's properties:</p> <p><strong><code>this.el</code></strong>: Is the instance root element. It allows you to safely query, manipulate the instance's DOM elements. ie: <code>this.el.querySelector('ul')</code></p> <p><strong><code>this.data</code></strong>: Gives you access to the reactive data. You can get, set and delete properties. Whenever a data is updated it will trigger re-render (if necessary), ie: <code>console.log(this.data.name)</code></p> <p><strong><code>this.render</code></strong> A function to manually re-render, ie: <code>this.render()</code></p> <p><strong><code>...this.$define-methods</code></strong> all of the defined methods, ie: <code>this.$my-defined-method()</code></p></p> <h3 id="defined-method">Defined Method</h3> <p>The example below showcases how methods can be used.</p> <pre><code class="js">
&lt;div id=&quot;root&quot;&gt;
  &lt;a @click=&quot;sayHello&quot; href=&quot;#&quot;&gt;Say Hello!&lt;/a&gt;

  &lt;input 
    type=&quot;text&quot; 
    name=&quot;color&quot; 
    @call=&quot;changeColor&quot; 
    r-value=&quot;this.defaultColor&quot;
  &gt; 

&lt;/div&gt;

&lt;script type=&quot;module&quot;&gt;

  reLiftHTML({
    el: '#root',
    data: {
      defaultColor: '#FFFFFF'
    },

    sayHello(event) {
      console.log('Hello World!');
    },

    changeColor(event) {
      const color = event.target.value;
      this.setBgColor(color);
    },

    setBgColor(color) {
      this.el.style.background = color;
    },

  })

&lt;/script&gt;

</code></pre> <h3 id="async-method">Async method</h3> <p>You can also setup Async methods with the <code>async/await</code>. </p> <pre><code class="js">
  reLiftHTML({
    el: '#root',

    async loadData() {
      this.data.status = 'loading...';
      const data = await fetch('url');
      const data = await resp.data;
      this.data.status = 'loading completed!';
    },

    async created(event) {
      await this.loadData();
    },

  })


</code></pre> </section> <hr>  <section class="doc" data-doc="directives.md"> <h2 id="directives">Directives</h2> <div class="toc"> <ul> <li><a href="#directives">Directives</a><ul> <li><a href="#r-if">r-if</a></li> <li><a href="#r-for">r-for</a><ul> <li><a href="#loop">Loop</a></li> <li><a href="#inner-loop">Inner Loop</a></li> <li><a href="#iterate-over-a-range">Iterate over a range</a></li> </ul> </li> <li><a href="#r-class">r-class</a></li> <li><a href="#r-value">r-value</a></li> <li><a href="#r-select">r-select</a></li> <li><a href="#r-checked">r-checked</a></li> </ul> </li> </ul> </div> <p>Directives are special attribute that start with <code>r-</code> that you place in HTML elements as a normal data attribute, ie: <code>&lt;span r-if="this.x === y"&gt;show&lt;/span&gt;</code>. They serve as shorthands to convert to template literals stuff that could be too challenging to write. </p> <pre><code>  // directive
  &lt;span r-if=&quot;this.index === 5&quot;&gt;Show me&lt;/span&gt;

  // The code above will be converted to 
  ${this.index === 5 ? `&lt;span&gt;Show me&lt;/span&gt;` : ``}

  // Here's how to iterate over a list of items
  &lt;ul&gt;
    &lt;li r-for=&quot;item in this.items&quot;&gt;${item}&lt;/li&gt;
  &lt;/ul&gt;

</code></pre> <p>Values can be of any javascript conditional. Values should not be placed in <code>${...}</code> inside of the directive. It should be written as normal string. </p> <p><strong>DO THIS</strong>: <code>&lt;span r-if="this.index === 5"&gt;show me&lt;/span&gt;</code></p> <p><strong>DON'T DO</strong>: <code>&lt;span r-if="${this.index === 5}"&gt;show me&lt;/span&gt;</code></p> <h3 id="r-if">r-if</h3> <p><code>r-if</code> can be used to conditionally add or remove the elements.The same way you would write your conditional in javascript. </p> <p><code>r-else</code> can also be used to indicate an "else block" for <code>r-if</code>. The element must immediately follow the <code>r-if</code>, or it will not be recognized.</p> <pre><code>  &lt;div id=&quot;root&quot;&gt;

    &lt;div r-if=&quot;this.count !== 5&quot;&gt;The count is not ${this.count}&lt;/div&gt;

    &lt;div r-if=&quot;this.isTrue&quot;&gt;Show me&lt;/div&gt;
    &lt;div r-else&gt; Show me ELSE&lt;/div&gt;

  &lt;/div&gt;

  &lt;script type=&quot;module&quot;&gt;
    reLiftHTML({
      el: '#root',
      data: {
        isTrue: true,
        count: 5
      }
    })
  &lt;/script&gt;

</code></pre> <hr /> <h3 id="r-for">r-for</h3> <p><code>r-for</code> can be used to iterate over a list of items. Underneath it will turn it into <code>map</code>.</p> <p>The <code>r-for</code> directive requires a special syntax in the form of <code>item in items</code>, where <code>items</code> is the source data Array and <code>item</code> is an alias for the Array element being iterated on.</p> <p>You can also have <code>item, index in items</code>, where <code>index</code> is tracking the number.</p> <h4 id="loop">Loop</h4> <pre><code>  &lt;div id=&quot;root&quot;&gt;
    &lt;ul&gt;
      &lt;li r-for=&quot;location in this.locations&quot;&gt;${location.name}&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;

  &lt;script type=&quot;module&quot;&gt;

    reLiftHTML({
      el: '#root',
      data: {
        locations: [
          {
            name: 'Charlotte'
          },
          {
            name: 'Atlanta'
          },
          {
            name: 'Concord'
          }
        ]
      }
    })
  &lt;/script&gt;

</code></pre> <h4 id="inner-loop">Inner Loop</h4> <pre><code>  &lt;div id=&quot;root&quot;&gt;
    &lt;ul&gt;
      &lt;li r-for=&quot;state in this.states&quot;&gt;
        ${state.name}

        &lt;ul&gt;
          &lt;li&gt;Cities&lt;/li&gt;
          &lt;li r-for=&quot;city in state.cities&quot;&gt;${city}&lt;/li&gt;
        &lt;/ul&gt;

      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;

  &lt;script type=&quot;module&quot;&gt;

    reLiftHTML({
      el: '#root',
      data: {
        states: [
          {
            name: 'NC',
            cities: [
              'Concord',
              'Charlotte',
              'Raleigh'
            ]
          },
          {
            name: 'Florida',
            cities: [
              'Tampa',
              'Miami',
              'Jacksonville'
            ]
          },
          {
            name: 'South Carolina',
            cities: [
              'Columbia',
              'Greenville'
            ]
          }
        ]
      }
    })
  &lt;/script&gt;
</code></pre> <h4 id="iterate-over-a-range">Iterate over a range</h4> <pre><code>
  &lt;div r-for=&quot;i in [...Array(5).keys()]&quot;&gt;I'm ${i}&lt;/div&gt;

</code></pre> <h3 id="r-class">r-class</h3> <p>(*not implemented yet)<br /> N/A</p> <h3 id="r-value">r-value</h3> <p>(*not complete)</p> <p><code>r-value</code> can be used in forms to automatically set values.</p> <pre><code>  &lt;input type=&quot;text&quot; r-value=&quot;this.item&quot;&gt;
</code></pre> <h3 id="r-select">r-select</h3> <p>(*not implemented yet)<br /> N/A</p> <h3 id="r-checked">r-checked</h3> <p>(*not implemented yet)<br /> N/A</p> </section> <hr>  <section class="doc" data-doc="events.md"> <h2 id="events">Events</h2> <div class="toc"> <ul> <li><a href="#events">Events</a><ul> <li><a href="#passing-values">Passing values</a></li> <li><a href="#call">@call</a></li> <li><a href="#events-name-list">Events Name List</a></li> </ul> </li> </ul> </div> <p>You can add event listener to elements by adding the <code>@</code> + the <code>$event-name</code> as attribute, and assign it the name of the method to bind it to: <code>&lt;a @click="sayHello" href="#"&gt;Say Hello!&lt;/a&gt;</code></p> <p>The $event-name must be the name of the event without <code>on</code>, ie: <code>@click</code> is VALID but <code>@onclick</code> is INVALID.</p> <p>The method must be in the context of the instace that's created.</p> <p>When an event is invoked, the <code>Event</code> object is passed to the method as the first and only argument. The <code>Event</code> object can be used to retrieve data attribute of the element, etc.</p> <pre><code class="html">
&lt;div id=&quot;root&quot;&gt;
  &lt;a @click=&quot;sayHello&quot; href=&quot;#&quot;&gt;Say Hello!&lt;/a&gt;
&lt;/div&gt;

&lt;script type=&quot;module&quot;&gt;

  reLiftHTML({
    el: '#root',
    data: {},

    sayHello(event) {
      console.log('Hello World!')
    }
  })

&lt;/script&gt;

</code></pre> <p>When the button is clicked it will 'Hello World' will be displayed on the console.</p> <h3 id="passing-values">Passing values</h3> <p>To pass values from the element to the event, we can use html attribute and retrieve the data from there. We can't pass object directly to the method. It has to be done via data attribute. With the data attribute, we can use it to retrieve some more data from some other sources.</p> <pre><code class="html">
&lt;div id=&quot;root&quot;&gt;
  &lt;button @click=&quot;sayHello&quot; data-name=&quot;Mardix&quot;&gt;Say Hello!&lt;/button&gt;
&lt;/div&gt;

&lt;script type=&quot;module&quot;&gt;

  reLiftHTML({
    el: '#root',
    data: {},

    sayHello(event) {
      const name = event.target.getAttribute('data-name');
      console.log(`Hello ${name}`)
    }
  })
&lt;/script&gt;
</code></pre> <p>Will now show <code>Hello Mardix</code></p> <h3 id="call">@call</h3> <p><code>@call</code> is a shorthand key that will assign the right event based on the element type.</p> <p>By default all <code>@call</code> will result into <code>@click</code>, except for the scenarios below:</p> <p><strong>HTMLAnchorElement</strong></p> <p>AHREF <code>@call</code> =&gt; <code>@click</code></p> <pre><code>&lt;a @call=&quot;something&quot;&gt;x&lt;/a&gt; to
&lt;a href=&quot;javascript:void(0);&quot; @click=&quot;something&quot;&gt;&lt;/a&gt;
</code></pre> <p><strong>HTMLInputElement &amp; HTMLTextAreaElement</strong></p> <p>FORMS: Input &amp; Textarea <code>@call</code> =&gt; <code>@input + @paste</code></p> <pre><code>&lt;input type=&quot;text&quot; @call=&quot;something&quot;&gt; to
&lt;input type=&quot;text&quot; @input=&quot;something&quot; @paste=&quot;something&quot;&gt;
</code></pre> <p><strong>HTMLSelectElement</strong></p> <p>FORMS: Select <code>@call</code> =&gt; <code>@change</code></p> <pre><code>&lt;select @call=&quot;something&quot;&gt;&lt;options...&gt;&lt;/select&gt;
&lt;select @change=&quot;something&quot;&gt;&lt;options...&gt;&lt;/select&gt;
</code></pre> <p><strong>HTMLFormElement</strong></p> <p>FORMS: Form <code>@call</code> =&gt; <code>@submit</code></p> <pre><code>&lt;form @call=&quot;something&quot;&gt;&lt;/form&gt;
&lt;form @submit=&quot;something&quot;&gt;&lt;/form&gt;
</code></pre> <h3 id="events-name-list">Events Name List</h3> <p>Here is the list of all the events accepted by reLift-HTML </p> <pre><code>@call
@click
@submit
@change
@input
@select
@focus
@blur
@hover
@reset
@keydown
@keypress
@keyup
@dblclick
@mouseenter
@mouseleave
@mousedown
@mousemove
@mouseout
@mouseover
@mouseup
@contextmenu
@drag
@dragend
@dragenter
@dragstart
@dragleave
@drop
@cut
@copy
@paste

</code></pre> </section> <hr>  <section class="doc" data-doc="shared-state.md"> <h2 id="shared-state">Shared State</h2> <div class="toc"> <ul> <li><a href="#shared-state">Shared State</a><ul> <li><a href="#state-manager-interface">State Manager Interface</a></li> <li><a href="#setup">Setup</a></li> <li><a href="#in-methods">In Methods</a></li> <li><a href="#in-template">In Template</a></li> <li><a href="#example-with-restated">Example with reStated</a></li> </ul> </li> </ul> </div> <p>To share state with multiple instances, it's recommended to have a state manager such as <a href="https://github.com/mardix/restated" target="_blank"><strong>*RESTATED</strong></a>, Redux, or look through this <a href="https://www.javascriptstuff.com/state-managers/" target="_blank">List of State Managers</a></p> <h3 id="state-manager-interface">State Manager Interface</h3> <p>For the to be hooked in reLift-HTML, it must have the following methods:</p> <p><strong><code>getState()</code></strong> : To return the full state of the store.</p> <p><strong><code>subscribe(callback:function)</code></strong>: A subscription method that will execute each the state is updated.</p> <p>If the state manager doesn't provide these methods by default, you can extend it yourself. </p> <pre><code class="js">  const myStateManager = new somethingSomething()

  // Now the store contains getState() and subscribe(callback)
  const store = {
    getState() {
      return myStateManager.state;
    },
    subscribe(callback) {
      return myStateManager.onChange(callback);
    },
    ...myStateManager
  }

</code></pre> <h3 id="setup">Setup</h3> <pre><code class="js">
reLiftHTML({
  el: '#root',
  data: {},
  $store: STORE_INSTANCE
})

</code></pre> <h3 id="in-methods">In Methods</h3> <p>The store is exposed in the methods by <code>this.$store</code>, which is the object that was passed. Therefor you can access anything from it.</p> <pre><code class="js">
reLiftHTML({
  el: '#root',
  data: {},
  $store: STORE_INSTANCE,
  doSomething() {
    this.$store.doSomething();
  }
})

</code></pre> <h3 id="in-template">In Template</h3> <p>To access properties from the store, <code>this.$store</code> is exposed and contain the values from <code>$store.getState()</code>. </p> <pre><code>  &lt;div id=&quot;root&quot;&gt;
    ${this.$store.fullName}
  &lt;/div&gt;
</code></pre> <h3 id="example-with-restated">Example with <strong>reStated</strong></h3> <hr /> <p><strong>reStated</strong></p> <p>An ambitiously tiny flux-like library to manage your state.</p> <p>Inspired by Redux and Vuex, <strong>reStated</strong> removes the boilerplate and keep it simple and flat. </p> <p>Unlike Redux, you don't need to return a new immutable object. You can mutate the state in place, and you definitely don't need to define a reducer. The action mutator is both your action and your reducer "at the same damn time" (Future's song)</p> <p>Unlike Vuex, you don't need to have actions and mutations. You can only mutate the state via your actions mutators which are just function that pass as first argument the current state to be mutated.</p> <p>Learn more about <a href="https://github.com/mardix/restated" target="_blank"><strong>RESTATED</strong></a></p> <hr /> <p>This is how we can use shared state with reStated.</p> <pre><code class="html">
&lt;script type=&quot;module&quot;&gt;
  import reLiftHTML from '//unpkg.com/relift-html';
  import reStated from '//unpkg.com/restated-lib';

  const store = reStated({
      name: '',
      lastName: '',
      fullName(state) =&gt; `${state.name} ${state.lastName}`,
      accountDetails: []
    }, {
      changeName(state, name) {
        state.name = name;
      },
      changeLastName(state, lastName) {
        state.lastName = lastName;
      },
      async loadAccount(state) {
        state.status = 'loading';
        const resp = await fetch(url);
        const data = await resp.json();

        // will be shared as this.$store.accountDetails
        state.accountDetails = data;

        state.status = 'done';
      }
    });

  // #rootA
  reLiftHTML({
    el: '#rootA',
    data: {},
    $store: store,
    loadAccount() {
      this.$store.doSomething();
    }
  })

  // #rootB
  reLiftHTML({
    el: '#rootB',
    data: {},
    $store: store
  })
&lt;/script&gt;


&lt;div id=&quot;rootA&quot;&gt;
  Hello ${this.$store.fullName}!

  &lt;button @call=&quot;loadAccount&quot;&gt;Load Account&lt;/button&gt;
&lt;/div&gt;

&lt;div id=&quot;rootB&quot;&gt;
  &lt;ul&gt;
    &lt;li r-for=&quot;item in this.$store.accountDetails&quot;&gt;${accountName}&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;

</code></pre> </section> <hr>  </div> </div> </div> </div>    <link rel="stylesheet" href="https://relift-html.js.org/static/vendor/highlight/styles/nord.css" type="text/css" >     <script type='text/javascript' src="https://relift-html.js.org/static/vendor/highlight/highlight.pack.js"></script>     <script type='text/javascript' src="https://relift-html.js.org/static/main.js"></script>     <script type="module" src="https://relift-html.js.org/static/pages_assets__/guide-index-html_b0d03653e0d141db8abc60b5652c6271.js"></script>   <div class="wrapper"> <hr /> <footer class="footer"> <section class="container"> &copy; 2019 reLift-HTML - License: MIT - <a target="_blank" href="https://github.com/mardix/relift-html">Github</a> - <a target="_blank" href="https://github.com/mardix/">Mardix</a> - Thanks to <a target="_blank" href="https://milligram.io/">Milligram CSS</a> </section> </footer> <hr /> </div> 